#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

function colorize(code, str) {
  return `\x1b[${code}m${str}\x1b[0m`;
}

const COLORS = {
  NAVY: '0;34', RED: '0;31', CYAN: '0;36', ORANGE: '1;31',
  YELLOW: '1;33', PINK: '1;35', AQUA: '1;36',
};

// uid/gid name caches
const uidCache = new Map();
const gidCache = new Map();

function getUsername(uid) {
  if (!uidCache.has(uid)) {
    try {
      uidCache.set(uid, execSync(`id -un ${uid}`, { encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe'] }).trim());
    } catch { uidCache.set(uid, String(uid)); }
  }
  return uidCache.get(uid);
}

function getGroupname(gid) {
  if (!gidCache.has(gid)) {
    try {
      const out = execSync(`dscl . -search /Groups PrimaryGroupID ${gid}`, { encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe'] });
      gidCache.set(gid, out.split(/\s+/)[0] || String(gid));
    } catch { gidCache.set(gid, String(gid)); }
  }
  return gidCache.get(gid);
}

function modeStr(mode) {
  const bits = [0o400, 0o200, 0o100, 0o040, 0o020, 0o010, 0o004, 0o002, 0o001];
  const chars = ['r', 'w', 'x', 'r', 'w', 'x', 'r', 'w', 'x'];
  return bits.map((b, i) => (mode & b) ? chars[i] : '-').join('');
}

function humanSize(bytes) {
  if (bytes > 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + 'M';
  if (bytes > 1024) return (bytes / 1024).toFixed(1) + 'K';
  return bytes + 'B';
}

function formatTime(date) {
  const y = date.getFullYear();
  const mo = String(date.getMonth() + 1).padStart(2, '0');
  const d = String(date.getDate()).padStart(2, '0');
  const h = String(date.getHours()).padStart(2, '0');
  const mi = String(date.getMinutes()).padStart(2, '0');
  const s = String(date.getSeconds()).padStart(2, '0');
  return `${y}-${mo}-${d} ${h}:${mi}:${s}`;
}

class Node {
  constructor(fullPath, opts) {
    this.fullPath = fullPath;
    this.name = path.basename(fullPath);
    this.stat = fs.lstatSync(fullPath);
    this.opts = opts;
  }

  get isDir() { return this.stat.isDirectory(); }
  get isSym() { return this.stat.isSymbolicLink(); }
  get isExec() { return !!(this.stat.mode & 0o111); }
  get isPipe() { return this.stat.isFIFO(); }
  get isSocket() { return this.stat.isSocket(); }
  get isBlock() { return this.stat.isBlockDevice(); }
  get isChar() { return this.stat.isCharacterDevice(); }

  get level() {
    if (this.isDir) return 1;
    if (this.isPipe) return 2;
    if (this.isSocket) return 3;
    if (this.isBlock) return 4;
    if (this.isChar) return 5;
    if (this.isSym) return 6;
    if (this.isExec) return 7;
    return 8;
  }

  get coloredName() {
    if (this.isDir) return colorize(COLORS.NAVY, this.name);
    if (this.isSym) return `${colorize(COLORS.CYAN, this.name)} -> ${fs.readlinkSync(this.fullPath)}`;
    if (this.isExec) return colorize(COLORS.RED, this.name);
    if (this.isPipe) return colorize(COLORS.ORANGE, this.name);
    if (this.isSocket) return colorize(COLORS.YELLOW, this.name);
    if (this.isBlock) return colorize(COLORS.PINK, this.name);
    if (this.isChar) return colorize(COLORS.AQUA, this.name);
    return this.name;
  }

  toString() {
    if (!this.opts.a) return this.coloredName;

    const size = this.opts.h
      ? humanSize(this.stat.size).padStart(6)
      : String(this.stat.size).padStart(10);
    const sep = this.opts.t ? '\t' : ' ';

    return [
      modeStr(this.stat.mode),
      getUsername(this.stat.uid),
      getGroupname(this.stat.gid),
      size,
      formatTime(this.stat.mtime),
      this.coloredName,
    ].join(sep);
  }

  compareTo(other) {
    if (this.level !== other.level) return this.level - other.level;
    const a = this.name, b = other.name;
    if (/^\d+$/.test(a) && /^\d+$/.test(b)) return Number(a) - Number(b);
    return a < b ? -1 : a > b ? 1 : 0;
  }
}

// Parse args
const opts = { a: false, h: false, t: false };
const positional = [];
for (const arg of process.argv.slice(2)) {
  if (arg.startsWith('-') && arg !== '-') {
    for (const c of arg.slice(1)) {
      if (c in opts) opts[c] = true;
    }
  } else {
    positional.push(arg);
  }
}

const target = positional[0] || '.';
if (!fs.existsSync(target)) {
  console.log(`${target}: No such file or directory`);
  process.exit(1);
}

const stat = fs.lstatSync(target);
if (stat.isDirectory()) {
  const entries = fs.readdirSync(target)
    .filter(e => e !== '.' && e !== '..')
    .map(e => new Node(path.join(target, e), opts))
    .sort((a, b) => a.compareTo(b));
  entries.forEach(e => console.log(e.toString()));
} else {
  console.log(new Node(target, opts).toString());
}
