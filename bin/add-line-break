#!/usr/bin/env node
// frozen_string_literal equivalent: strings are immutable in JS by default
//
// 概要:
//   指定した Markdown/テキストファイルを下記ルールで整形し、
//   元ファイルを上書き保存 (一回目だけ差分が出る) します。
//   以後同じファイルに対し何度実行しても差分が出ない idempotent 仕様。

const fs = require('fs');
const path = require('path');

const ZERO_WIDTH_SPACE = '\u200B';
const LINE_BREAK = `${ZERO_WIDTH_SPACE}  `;

const SENTENCE_ENDS = ['。', '!', '！'];
const OPENING_QUOTES = ['「', '『'];
const CLOSING_QUOTES = ['」', '』'];

const AUTO_BREAK_PATTERNS = [
  /^\s*$/,           // 空行
  /^\s*#/,           // 見出し
  /^\s*[-+*]\s+/,    // 箇条書き
  /^\s*\d+\.\s+/,    // 番号付きリスト
  /^\s*>/,           // 引用
  /^\s*```/,         // コードフェンス
];

const SECTION_HEADER_RE = /^\s*(\*\*)?◎/;

function autoBreakLine(line) {
  return AUTO_BREAK_PATTERNS.some(re => re.test(line));
}

function alreadyFormatted(line) {
  return line.endsWith(LINE_BREAK);
}

function formatText(lines) {
  const out = [];

  for (let idx = 0; idx < lines.length; idx++) {
    const raw = lines[idx];

    if (alreadyFormatted(raw)) {
      out.push(raw);
      continue;
    }

    const line = raw.trimEnd();
    if (autoBreakLine(line)) {
      out.push(line);
      continue;
    }

    // ◎ セクションタイトル
    if (SECTION_HEADER_RE.test(line)) {
      let result = line;
      if (!result.startsWith('**')) result = `**${result}**`;
      if (!alreadyFormatted(result)) result += LINE_BREAK;
      out.push(result);
      if (lines[idx + 1] && lines[idx + 1].startsWith('◎')) {
        out.push('');
      }
      continue;
    }

    // 通常段落 → 文単位に分割
    let buffer = '';
    let inQuote = false;
    let i = 0;

    while (i < line.length) {
      const ch = line[i];
      buffer += ch;

      if (OPENING_QUOTES.includes(ch)) {
        inQuote = true;
      } else if (inQuote && CLOSING_QUOTES.includes(ch)) {
        inQuote = false;
        out.push(`${buffer.trim()}${LINE_BREAK}`);
        buffer = '';
      } else if (!inQuote && SENTENCE_ENDS.includes(ch)) {
        if (i + 1 < line.length && CLOSING_QUOTES.includes(line[i + 1])) {
          i++;
          buffer += line[i];
        }
        out.push(`${buffer.trim()}${LINE_BREAK}`);
        buffer = '';
      }

      i++;
    }

    if (buffer.trim()) {
      out.push(`${buffer.trim()}${LINE_BREAK}`);
    }
  }

  return out.join('\n');
}

// CLI
const filePath = process.argv[2];
if (!filePath) {
  console.error(`Usage: node ${path.basename(__filename)} INPUT_FILE`);
  process.exit(1);
}

if (!fs.existsSync(filePath)) {
  console.error(`File not found: ${filePath}`);
  process.exit(1);
}

const originalLines = fs.readFileSync(filePath, 'utf8').split('\n');
// Remove trailing empty element from split if file ends with newline
if (originalLines[originalLines.length - 1] === '') originalLines.pop();

const formatted = formatText(originalLines);
fs.writeFileSync(filePath, formatted, 'utf8');
console.log(`Formatted (idempotent) → ${filePath}`);
