#!/usr/bin/env node

const readline = require('readline');

const HELP = `coloring every kind of file roughly

\\e[0;30m
str
\\e[0m


# Normal             # Bright FG       # Bright BG
\x1b[0;30m BLACK  \x1b[0m = "0;30"   \x1b[0;90m BLACK  \x1b[0m = "0;90"  \x1b[0;100m BLACK  \x1b[0m = "0;100"
\x1b[0;31m RED    \x1b[0m = "0;31"   \x1b[0;91m RED    \x1b[0m = "0;91"  \x1b[0;101m RED    \x1b[0m = "0;101"
\x1b[0;32m GREEN  \x1b[0m = "0;32"   \x1b[0;92m GREEN  \x1b[0m = "0;92"  \x1b[0;102m GREEN  \x1b[0m = "0;102"
\x1b[0;33m BROWN  \x1b[0m = "0;33"   \x1b[0;93m BROWN  \x1b[0m = "0;93"  \x1b[0;103m BROWN  \x1b[0m = "0;103"
\x1b[0;34m NAVY   \x1b[0m = "0;34"   \x1b[0;94m NAVY   \x1b[0m = "0;94"  \x1b[0;104m NAVY   \x1b[0m = "0;104"
\x1b[0;35m PURPLE \x1b[0m = "0;35"   \x1b[0;95m PURPLE \x1b[0m = "0;95"  \x1b[0;105m PURPLE \x1b[0m = "0;105"
\x1b[0;36m CYAN   \x1b[0m = "0;36"   \x1b[0;96m CYAN   \x1b[0m = "0;96"  \x1b[0;106m CYAN   \x1b[0m = "0;106"
\x1b[0;37m GRAY   \x1b[0m = "0;37"   \x1b[0;97m GRAY   \x1b[0m = "0;97"  \x1b[0;107m GRAY   \x1b[0m = "0;107"


$ cat access.log | color          # all
$ cat access.log | color keyword  # only keyword`;

if (process.argv[2] === '-h' || process.stdin.isTTY) {
  console.log(HELP);
  process.exit(0);
}

const LINE_COLORS = [
  '1;91', '0;96', '1;92', '0;95', '1;93', '0;94', '1;95', '0;92',
  '1;94', '0;93', '1;96', '0;91', '1;97', '0;97', '1;90', '0;90',
];

const WORD_COLORS = ['1;91', '1;92', '1;93', '1;95', '1;94', '1;96', '1;90'];

function colorize(str, code) {
  return `\x1b[${code}m${str}\x1b[0m`;
}

function colorLine(line) {
  const tokens = [];
  let token = '';
  let state = '';

  for (const c of line) {
    token += c;
    if (c === '"') {
      if (state === '') { state = '"'; }
      else if (state === '"') { tokens.push(token); token = ''; state = ''; }
    } else if ((c === '[' || c === '(') && state !== '"') {
      state = c;
    } else if ((c === ']' || c === ')') && state !== '"') {
      tokens.push(token); token = ''; state = '';
    } else if ((c === ' ' || c === '\t') && !['[', '(', '"'].includes(state)) {
      tokens.push(token); token = '';
    }
  }
  if (token) tokens.push(token);

  return tokens.map((t, i) => colorize(t, LINE_COLORS[i % LINE_COLORS.length])).join('');
}

const keywords = process.argv.slice(2);
const rl = readline.createInterface({ input: process.stdin });

rl.on('line', line => {
  if (keywords.length > 0) {
    let result = line;
    keywords.forEach((word, i) => {
      const re = new RegExp(word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
      const code = WORD_COLORS[i % WORD_COLORS.length];
      result = result.replace(re, match => colorize(match, code));
    });
    process.stdout.write(result + '\n');
  } else {
    process.stdout.write(colorLine(line) + '\n');
  }
});
