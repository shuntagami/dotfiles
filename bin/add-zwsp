#!/usr/bin/env node
//
// 各行末に「ZERO WIDTH SPACE + 半角スペース×2」を付与。
// 既に付与済み／空行／Markdown が自動改行扱いする行はスキップ。
// 同じファイルを直接上書きし、再実行しても差分の出ない idempotent 仕様。

const fs = require('fs');
const path = require('path');

const ZERO_WIDTH_SPACE = '\u200B';
const LINE_BREAK = `${ZERO_WIDTH_SPACE}  `;

const AUTO_BREAK_PATTERNS = [
  /^\s*$/,                // 空行
  /^\s*#/,                // 見出し
  /^\s*[-+*]\s+/,         // 箇条書き
  /^\s*\d+\.\s+/,         // 番号付きリスト
  /^\s*>/,                // 引用
  /^\s*```/,              // コードフェンス
  /^\s*\|/,               // テーブル行
  /^\s*[-*_]{3,}\s*$/,    // 区切り線
];

function autoBreakLine(line) {
  return AUTO_BREAK_PATTERNS.some(re => re.test(line));
}

function alreadyProcessed(line) {
  return line.endsWith(LINE_BREAK);
}

function addLineBreak(lines) {
  return lines.map(raw => {
    const body = raw.replace(/\n$/, '');
    const hasNewline = raw.endsWith('\n');

    if (alreadyProcessed(body) || autoBreakLine(body)) {
      return raw;
    }
    return `${body}${LINE_BREAK}${hasNewline ? '\n' : ''}`;
  });
}

const filePath = process.argv[2];
if (!filePath) {
  console.error(`Usage: node ${path.basename(__filename)} TARGET_FILE`);
  process.exit(1);
}

if (!fs.existsSync(filePath)) {
  console.error(`File not found: ${filePath}`);
  process.exit(1);
}

const original = fs.readFileSync(filePath, 'utf8');
const lines = original.split(/(?<=\n)/); // split preserving newlines
const processed = addLineBreak(lines);
const result = processed.join('');

if (result !== original) {
  fs.writeFileSync(filePath, result, 'utf8');
  console.log(`Updated: ${filePath}`);
} else {
  console.log(`No changes: ${filePath}`);
}
